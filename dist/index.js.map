{"version":3,"sources":["../src/index.js"],"names":["quote","value","objectToQuery","Object","keys","obj","length","i","max","key","strings","push","join","toExpression","operator","options","field","isNullArray","inputArray","len","module","exports","and","expressions","or","not","expression","rangeNum","Error","upperBound","lowerBound","rangeStr","termNum","termStr","matchall","near","distance","phrase","prefix"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\n'use strict';\n\nexport type Expression = string | null\n\ntype Operator =\n\t\"and\" |\n\t\"range\" |\n\t\"not\" |\n\t\"or\" |\n\t\"prefix\" |\n\t\"phrase\" |\n\t\"term\" |\n\t\"near\"\n\ntype Options = { [x: string]: string | number }\n\n\nfunction quote(value: string): string {\n\treturn `'${value}'`;\n}\n\nfunction objectToQuery(obj: ?Object): string {\n\tif (obj == null) return '';\n\tconst keys = Object.keys(obj);\n\tconst max = keys.length;\n\tlet i = 0;\n\tlet strings = [];\n\n\twhile (i < max) {\n\t\ti++;\n\t\tconst key = keys[i];\n\t\tconst value = obj[key];\n\t\tif (typeof value === \"string\") {\n\t\t\tstrings.push(`${key}=\"${value}\"`);\n\t\t} else {\n\t\t\tstrings.push(`${key}=${value}`);\n\t\t}\n\t}\n\treturn strings.join(' ');\n}\n\nfunction toExpression(operator: Operator, field: ?string, value: Expression | number, options: ?Options): Expression {\n\t/*:: if(value==null) return null;*/\n\tif (field == null) {\n\t\treturn `(${operator} ${objectToQuery(options)}` + ` ${value})`;\n\t} else {\n\t\treturn `(${operator} field=${field} ${objectToQuery(options)}` + ` ${value})`;\n\t}\n}\n\nfunction isNullArray(inputArray: any[]): boolean {\n\tfor (let i = 0, len = inputArray.length; i < len; i += 1)\n\t\tif (inputArray[i] != null)\n\t\t\treturn false;\n\treturn true;\n}\n\nmodule.exports = {\n\tand: function (options: ?Options, ...expressions: Expression[]): Expression {\n\t\tif (isNullArray(expressions)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn toExpression('and', undefined, expressions.join(' '), options);\n\t},\n\n\tor: function (options: ?Options, ...expressions: Expression[]): Expression {\n\t\tif (isNullArray(expressions)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn toExpression('or', undefined, expressions.join(' '), options);\n\t},\n\n\tnot: function (options: ?Options, expression: Expression): Expression {\n\t\tif (expression == null) return null;\n\t\treturn toExpression('not', undefined, expression, options);\n\t},\n\n\trangeNum: function (field: string, lowerBound: ?number, upperBound: ?number, options: ?Options): Expression {\n\t\tif (field == null) throw new Error('Field must be defined in range');\n\t\tif ((lowerBound == null) && (upperBound == null)) return null;\n\n\t\tlet expression = null;\n\t\tif (lowerBound == null && upperBound != null) {\n\t\t\texpression = `{,${upperBound}]`;\n\t\t} else if (upperBound == null && lowerBound != null) {\n\t\t\texpression = `[${lowerBound},}`;\n\t\t} else {\n\t\t\t/*:: if(lowerBound!=null && upperBound!=null)*/\n\t\t\texpression = `[${lowerBound},${upperBound}]`;\n\t\t}\n\n\t\treturn toExpression('range', field, expression, options);\n\t},\n\n\trangeStr: function (field: string, lowerBound: ?string, upperBound: ?string, options: ?Options): Expression {\n\t\tif (field == null) throw new Error('Field must be defined in range');\n\t\tif ((lowerBound == null) && (upperBound == null)) return null;\n\n\t\tlet expression = null;\n\t\tif (lowerBound == null && upperBound != null) {\n\t\t\texpression = `{,'${upperBound}']`;\n\t\t} else if (upperBound == null && lowerBound != null) {\n\t\t\texpression = `['${lowerBound}',}`;\n\t\t} else {\n\t\t\t/*:: if(lowerBound!=null && upperBound!=null) */\n\t\t\texpression = `['${lowerBound}','${upperBound}']`;\n\t\t}\n\n\t\treturn toExpression('range', field, expression, options);\n\t},\n\n\ttermNum: function (field: string, value: ?number, options: ?Options): Expression {\n\t\tif (value == null) return null;\n\n\t\treturn toExpression('term', field, value, options);\n\t},\n\n\ttermStr: function (field: string, value: ?string, options: ?Options): Expression {\n\t\tif (value == null) return null;\n\n\t\treturn toExpression('term', field, quote(value), options);\n\t},\n\n\tmatchall: '(matchall)',\n\n\tnear: function (field: string, value: ?string[], distance: number, options: ?Options): Expression {\n\t\tif (value == null) return null;\n\n\t\tif (options == null) {\n\t\t\toptions = {distance: distance};\n\t\t} else {\n\t\t\toptions.distance = distance;\n\t\t}\n\t\treturn toExpression('near', field, quote(value.join(\" \")), options);\n\t},\n\n\tphrase: function (field: string, value: ?string, options: ?Options): Expression {\n\t\tif (value == null) return null;\n\n\t\treturn toExpression('phrase', field, quote(value), options);\n\t},\n\n\tprefix: function (field: string, value: ?string, options: ?Options): Expression {\n\t\tif (value == null) return null;\n\n\t\treturn toExpression('prefix', field, quote(value), options);\n\t}\n};\n"]}